import numpy as np
import matplotlib.pyplot as plt

# 1. Βασικές Παράμετροι
N = 1000  # Πλήθος δειγμάτων
L = 3  # Τάξη φίλτρου => 4 συντελεστές (w0, w1, w2, w3)
mu = 0.01  # Μέγεθος βήματος (κατάλληλη τιμή για ομαλή σύγκλιση)
np.random.seed(0)  # Για αναπαραγωγιμότητα (προαιρετικό)

# 2. Δημιουργία εισόδου x(n): λευκός Gaussian θόρυβος (mean=0, var=1)
x = np.random.normal(0, 1, N)


# -------------------------------------------------------------------
# ΣΥΝΑΡΤΗΣΗ LMS ΠΟΥ ΠΡΟΣΑΡΜΟΖΕΤΑΙ ΣΕ ΧΡΟΝΙΚΑ ΜΕΤΑΒΑΛΛΟΜΕΝΟ ΣΥΣΤΗΜΑ
# -------------------------------------------------------------------
def lms_time_varying(x, b_of_n, mu, N, L):
    """
    Εκτελεί τον αλγόριθμο LMS για την ταυτοποίηση ενός χρονικά μεταβαλλόμενου
    συστήματος:
       h(n) = b(n)*δ[n] - 0.4δ[n-1] - 4δ[n-2] + 0.5δ[n-3].
    Η είσοδος είναι x(n), το βήμα LMS είναι mu, και το FIR φίλτρο έχει L+1 βάρη.

    Επιστρέφει τα διανύσματα:
       e_vec   : το σφάλμα e(n) σε κάθε χρονική στιγμή
       w_evol  : πίνακας (N x (L+1)) με την εξέλιξη των βαρών w(n)
    """
    w_current = np.zeros(L + 1)  # αρχικοποίηση βαρών
    e_vec = np.zeros(N)
    w_evol = np.zeros((N, L + 1))

    for n in range(N):
        # Υπολογισμός της "πραγματικής" εξόδου d(n) από το χρονικά μεταβαλλόμενο FIR
        # d(n) = b(n)*x(n) - 0.4*x(n-1) - 4*x(n-2) + 0.5*x(n-3)
        # με την εκάστοτε τιμή b(n).
        b_n = b_of_n(n)  # συντελεστής b(n) για το συγκεκριμένο n
        d_n = 0.0
        d_n += b_n * x[n]
        if n >= 1: d_n -= 0.4 * x[n - 1]
        if n >= 2: d_n -= 4.0 * x[n - 2]
        if n >= 3: d_n += 0.5 * x[n - 3]

        # Δημιουργία διανύσματος εισόδου στο φίλτρο w(n):
        # x_vec = [ x(n), x(n-1), x(n-2), x(n-3) ]
        x_vec = np.zeros(L + 1)
        x_vec[0] = x[n]
        if n >= 1: x_vec[1] = x[n - 1]
        if n >= 2: x_vec[2] = x[n - 2]
        if n >= 3: x_vec[3] = x[n - 3]

        # Έξοδος του εκτιμώμενου φίλτρου y(n)
        y_n = np.dot(w_current, x_vec)

        # Σφάλμα e(n) = d(n) - y(n)
        e_n = d_n - y_n
        e_vec[n] = e_n

        # Ενημέρωση βαρών LMS
        w_current = w_current + mu * e_n * x_vec

        # Αποθήκευση της τρέχουσας κατάστασης βαρών
        w_evol[n, :] = w_current

    return e_vec, w_evol


# -------------------------------------------------------------------
# 3. ΟΡΙΣΜΟΣ b(n) ΓΙΑ ΤΙΣ ΔΥΟ ΠΕΡΙΠΤΩΣΕΙΣ
# -------------------------------------------------------------------
def b_smooth(n):
    # Ομαλή μεταβολή: b(n) = 1 / (1 + e^(-0.02*n))
    return 1.0 / (1.0 + np.exp(-0.02 * n))


def b_abrupt(n):
    # Ακαριαία μεταβολή:
    #  b(n) = 100 για 1 <= n <= 500
    #         0   για 501 <= n <= 1000
    if 1 <= n <= 500:
        return 100.0
    else:
        return 0.0


# -------------------------------------------------------------------
# 4. ΕΚΤΕΛΕΣΗ ΠΕΙΡΑΜΑΤΩΝ ΓΙΑ ΚΑΘΕ b(n)
# -------------------------------------------------------------------
e_smooth, w_smooth = lms_time_varying(x, b_smooth, mu, N, L)
e_abrupt, w_abrupt = lms_time_varying(x, b_abrupt, mu, N, L)

# 5. Καμπύλη Μάθησης: θα σχεδιάσουμε e^2(n) σε συνάρτηση του n.
mse_smooth = e_smooth ** 2
mse_abrupt = e_abrupt ** 2

# -------------------------------------------------------------------
# 6. Σχεδίαση/Τύπωμα Καμπυλών Μάθησης
# -------------------------------------------------------------------
plt.figure(figsize=(10, 5))

plt.subplot(1, 2, 1)
plt.plot(mse_smooth, label='Ομαλή μεταβολή b(n)')
plt.title('Καμπύλη μάθησης - ομαλή μεταβολή')
plt.xlabel('n')
plt.ylabel('e^2(n)')
plt.grid(True)
plt.legend()

plt.subplot(1, 2, 2)
plt.plot(mse_abrupt, color='red', label='Ακαριαία μεταβολή b(n)')
plt.title('Καμπύλη μάθησης - ακαριαία μεταβολή')
plt.xlabel('n')
plt.ylabel('e^2(n)')
plt.grid(True)
plt.legend()

plt.suptitle('Σύγκριση Καμπύλης Μάθησης LMS για Ομαλή και Ακαριαία Μεταβολή (μ = 0.01)')
plt.tight_layout()
plt.show()
